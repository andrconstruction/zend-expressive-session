{
    "docs": [
        {
            "location": "/",
            "text": "zend-expressive-session\n\n\n\n\n\n\nThis library provides session handling middleware for PSR-7 applications, using\nan adapter-based approach that will allow usage of ext-session, JWT, or other\napproaches.\n\n\n\n\nNOT YET RELEASED\n\n\nThis package is an experiment, and undergoing heavy architectural design\ncurrently. As such, it is not yet on Packagist. You will need to add a\nrepository to your \ncomposer.json\n if you wish to use it at this time.\n\n\nUse at your own risk!\n\n\n\n\nInstallation\n\n\nRun the following to install this library:\n\n\n$ composer require zendframework/zend-expressive-session\n\n\n\n\nDocumentation\n\n\nDocumentation is \nin the doc tree\n, and can be compiled using \nmkdocs\n:\n\n\n$ mkdocs build\n\n\n\n\n~~You may also \nbrowse the documentation online\n.~~\n\n\nBasic usage\n\n\nThe default use case is to use the shipped \nPhpSessionPersistence\n adapter with\nthe shipped \nSessionMiddleware\n. As such, you can pipe it to your application:\n\n\n$app->pipe(SessionMiddleware::class);\n\n\n\n\nYou can also pipe it within routed middleware:\n\n\n$app->post('/contact/process', [\n    \\Zend\\Expressive\\Session\\SessionMiddleware::class,\n    \\App\\Contact\\ProcessHandler::class\n]);\n\n\n\n\nOnce the middleware is in place, you can access the session container from your\nother middleware via the request attribute\n\nZend\\Expressive\\Session\\SessionMiddleare::SESSION_ATTRIBUTE\n:\n\n\nuse Zend\\Expressive\\Session\\SessionMiddleware;\n\n$session = $request->getAttribute(SessionMiddleware::SESSION_ATTRIBUTE);\n$session->get('some-key');\n$session->unset('some-key');\n$session->set('some-key', $value);\n\n\n\n\nCustom persistence\n\n\nTo use custom persistence \u2014 e.g., a JWT-based approach \u2014 implement\n\nZend\\Expressive\\Session\\SessionPersistenceInterface\n:\n\n\nnamespace Zend\\Expressive\\Session;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface SessionPersistenceInterface\n{\n    /**\n     * Initialize the session data instance associated with the persistence\n     * engine based on the current request.\n     */\n    public function initializeSessionFromRequest(ServerRequestInterface $request) : SessionInterface;\n\n    /**\n     * Persist the session data instance.\n     *\n     * Persists the session data, returning a response instance with any\n     * artifacts required to return to the client.\n     */\n    public function persistSession(SessionInterface $session, ResponseInterface $response) : ResponseInterface;\n}\n\n\n\n\nOnce implemented, create an alternate factory for the\n\nZend\\Expressive\\Session\\SessionMiddleware\n service:\n\n\nnamespace App\\Session;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Session\\SessionMiddleware;\n\nclass SessionMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container) : SessionMiddleware\n    {\n        // Where App\\Session\\JwtPersistence implements SessionPersistenceInterface\n        return new SessionMiddleware($container->get(JwtPersistence::class));\n    }\n}\n\n\n\n\nOnce the factory exists, configure your application to use this factory; this is\ntypically done via an override in your \nconfig/autoload/dependencies.global.php\n\nfile:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            \\Zend\\Expressive\\Session\\SessionMiddleware::class => App\\Session\\SessionMiddlewareFactory::class,\n        ],\n    ],\n];",
            "title": "Home"
        },
        {
            "location": "/#zend-expressive-session",
            "text": "This library provides session handling middleware for PSR-7 applications, using\nan adapter-based approach that will allow usage of ext-session, JWT, or other\napproaches.",
            "title": "zend-expressive-session"
        },
        {
            "location": "/#not-yet-released",
            "text": "This package is an experiment, and undergoing heavy architectural design\ncurrently. As such, it is not yet on Packagist. You will need to add a\nrepository to your  composer.json  if you wish to use it at this time.  Use at your own risk!",
            "title": "NOT YET RELEASED"
        },
        {
            "location": "/#installation",
            "text": "Run the following to install this library:  $ composer require zendframework/zend-expressive-session",
            "title": "Installation"
        },
        {
            "location": "/#documentation",
            "text": "Documentation is  in the doc tree , and can be compiled using  mkdocs :  $ mkdocs build  ~~You may also  browse the documentation online .~~",
            "title": "Documentation"
        },
        {
            "location": "/#basic-usage",
            "text": "The default use case is to use the shipped  PhpSessionPersistence  adapter with\nthe shipped  SessionMiddleware . As such, you can pipe it to your application:  $app->pipe(SessionMiddleware::class);  You can also pipe it within routed middleware:  $app->post('/contact/process', [\n    \\Zend\\Expressive\\Session\\SessionMiddleware::class,\n    \\App\\Contact\\ProcessHandler::class\n]);  Once the middleware is in place, you can access the session container from your\nother middleware via the request attribute Zend\\Expressive\\Session\\SessionMiddleare::SESSION_ATTRIBUTE :  use Zend\\Expressive\\Session\\SessionMiddleware;\n\n$session = $request->getAttribute(SessionMiddleware::SESSION_ATTRIBUTE);\n$session->get('some-key');\n$session->unset('some-key');\n$session->set('some-key', $value);",
            "title": "Basic usage"
        },
        {
            "location": "/#custom-persistence",
            "text": "To use custom persistence \u2014 e.g., a JWT-based approach \u2014 implement Zend\\Expressive\\Session\\SessionPersistenceInterface :  namespace Zend\\Expressive\\Session;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface SessionPersistenceInterface\n{\n    /**\n     * Initialize the session data instance associated with the persistence\n     * engine based on the current request.\n     */\n    public function initializeSessionFromRequest(ServerRequestInterface $request) : SessionInterface;\n\n    /**\n     * Persist the session data instance.\n     *\n     * Persists the session data, returning a response instance with any\n     * artifacts required to return to the client.\n     */\n    public function persistSession(SessionInterface $session, ResponseInterface $response) : ResponseInterface;\n}  Once implemented, create an alternate factory for the Zend\\Expressive\\Session\\SessionMiddleware  service:  namespace App\\Session;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Session\\SessionMiddleware;\n\nclass SessionMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container) : SessionMiddleware\n    {\n        // Where App\\Session\\JwtPersistence implements SessionPersistenceInterface\n        return new SessionMiddleware($container->get(JwtPersistence::class));\n    }\n}  Once the factory exists, configure your application to use this factory; this is\ntypically done via an override in your  config/autoload/dependencies.global.php \nfile:  return [\n    'dependencies' => [\n        'factories' => [\n            \\Zend\\Expressive\\Session\\SessionMiddleware::class => App\\Session\\SessionMiddlewareFactory::class,\n        ],\n    ],\n];",
            "title": "Custom persistence"
        },
        {
            "location": "/intro/",
            "text": "zend-expressive-session\n\n\nWeb applications often need to perist user state between requests, and the\ngenerally accepted way to do so is via \nsessions\n. While PHP provides its own\nsession extension, it:\n\n\n\n\nuses global functions that affect global state.\n\n\nrelies on a superglobal for access to both read and write the session data.\n\n\nincurs either filesystem or network I/O on every request, depending on the\n  session storage handler.\n\n\ncan clobber the \nSet-Cookie\n header when other processes also set it.\n\n\n\n\nSome projects, such as \npsr-7-sessions/storageless\n,\ntake a different approach, using \nJSON Web Tokens\n (JWT).\n\n\nThe goals of zend-expressive-session are:\n\n\n\n\nto abstract the way users interact with session storage.\n\n\nto abstract how sessions are persisted, to allow both standard ext-session,\n  but also other paradigms such as JWT.\n\n\nto provide session capabilities that \"play nice\" with\n  \nPSR-7\n and middleware.\n\n\n\n\nInstallation\n\n\nUse \nComposer\n to install this package:\n\n\n$ composer require zendframework/zend-expressive-session\n\n\n\n\nHowever, the package is not immediately useful unless you have a persistence\nadapter. If you are okay with using ext-session, you can install the following\npackage as well:\n\n\n$ composer require zendframework/zend-expressive-session-ext\n\n\n\n\nFeatures\n\n\nzend-expressive-session provides the following:\n\n\n\n\nInterfaces for:\n\n\nsession containers\n\n\nsession persistence\n\n\n\n\n\n\nAn implementation of the session container.\n\n\nA \"lazy-loading\" implementation of the session container, to allow delaying\n  any de/serialization and/or I/O processes until session data is requested;\n  this implementation decorates a normal session container.\n\n\nPSR-7 middleware that:\n\n\ncomposes a session persistence implementation.\n\n\ninitializes the lazy-loading session container, using the session\n  persistence implementation.\n\n\ndelegates to the next middleware, passing the session container into the\n  request.\n\n\nfinalizes the session before returning the response.\n\n\n\n\n\n\n\n\nPersistence implementations locate session information from the requests (e.g.,\nvia a cookie) in order to initialize the session. On completion of the request,\nthey examine the session container for changes and/or to see if it is empty, and\nprovide data to the response so as to notify the client of the session (e.g.,\nvia a \nSet-Cookie\n header).\n\n\nNote that the goals of this package are solely focused on \nsession persistence\n\nand \naccess to session data by middleware\n. If you also need other features\noften related to session data, you may want to consider the following packages:\n\n\n\n\nzend-expressive-flash\n: \n  provides flash message capabilities.\n\n\nzend-expressive-csrf\n: \n  provides CSRF token generation, storage, and verification, using either a\n  session container, or flash messages.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#zend-expressive-session",
            "text": "Web applications often need to perist user state between requests, and the\ngenerally accepted way to do so is via  sessions . While PHP provides its own\nsession extension, it:   uses global functions that affect global state.  relies on a superglobal for access to both read and write the session data.  incurs either filesystem or network I/O on every request, depending on the\n  session storage handler.  can clobber the  Set-Cookie  header when other processes also set it.   Some projects, such as  psr-7-sessions/storageless ,\ntake a different approach, using  JSON Web Tokens  (JWT).  The goals of zend-expressive-session are:   to abstract the way users interact with session storage.  to abstract how sessions are persisted, to allow both standard ext-session,\n  but also other paradigms such as JWT.  to provide session capabilities that \"play nice\" with\n   PSR-7  and middleware.",
            "title": "zend-expressive-session"
        },
        {
            "location": "/intro/#installation",
            "text": "Use  Composer  to install this package:  $ composer require zendframework/zend-expressive-session  However, the package is not immediately useful unless you have a persistence\nadapter. If you are okay with using ext-session, you can install the following\npackage as well:  $ composer require zendframework/zend-expressive-session-ext",
            "title": "Installation"
        },
        {
            "location": "/intro/#features",
            "text": "zend-expressive-session provides the following:   Interfaces for:  session containers  session persistence    An implementation of the session container.  A \"lazy-loading\" implementation of the session container, to allow delaying\n  any de/serialization and/or I/O processes until session data is requested;\n  this implementation decorates a normal session container.  PSR-7 middleware that:  composes a session persistence implementation.  initializes the lazy-loading session container, using the session\n  persistence implementation.  delegates to the next middleware, passing the session container into the\n  request.  finalizes the session before returning the response.     Persistence implementations locate session information from the requests (e.g.,\nvia a cookie) in order to initialize the session. On completion of the request,\nthey examine the session container for changes and/or to see if it is empty, and\nprovide data to the response so as to notify the client of the session (e.g.,\nvia a  Set-Cookie  header).  Note that the goals of this package are solely focused on  session persistence \nand  access to session data by middleware . If you also need other features\noften related to session data, you may want to consider the following packages:   zend-expressive-flash : \n  provides flash message capabilities.  zend-expressive-csrf : \n  provides CSRF token generation, storage, and verification, using either a\n  session container, or flash messages.",
            "title": "Features"
        },
        {
            "location": "/session/",
            "text": "Session Containers\n\n\nSession containers are the primary interface with which most application\ndevelopers will work; they contain the data currently in the session, and allow\nyou to push data to the session.\n\n\nAll session containers implement \nZend\\Expressive\\Session\\SessionInterface\n:\n\n\nnamespace Zend\\Expressive\\Session;\n\ninterface SessionInterface\n{\n    /**\n     * Serialize the session data to an array for storage purposes.\n     */\n    public function toArray() : array;\n\n    /**\n     * Retrieve a value from the session.\n     *\n     * @param mixed $default Default value to return if $name does not exist.\n     * @return mixed\n     */\n    public function get(string $name, $default = null);\n\n    /**\n     * Whether or not the container has the given key.\n     */\n    public function has(string $name) : bool;\n\n    /**\n     * Set a value within the session.\n     *\n     * Values MUST be serializable in any format; we recommend ensuring the\n     * values are JSON serializable for greatest portability.\n     *\n     * @param mixed $value\n     */\n    public function set(string $name, $value) : void;\n\n    /**\n     * Remove a value from the session.\n     */\n    public function unset(string $name) : void;\n\n    /**\n     * Clear all values.\n     */\n    public function clear() : void;\n\n    /**\n     * Does the session contain changes? If not, the middleware handling\n     * session persistence may not need to do more work.\n     */\n    public function hasChanged() : bool;\n\n    /**\n     * Regenerate the session.\n     *\n     * This can be done to prevent session fixation. When executed, it SHOULD\n     * return a new instance; that instance should always return true for\n     * isRegenerated().\n     *\n     * An example of where this WOULD NOT return a new instance is within the\n     * shipped LazySession, where instead it would return itself, after\n     * internally re-setting the proxied session.\n     */\n    public function regenerate(): SessionInterface;\n\n    /**\n     * Method to determine if the session was regenerated; should return\n     * true if the instance was produced via regenerate().\n     */\n    public function isRegenerated() : bool;\n}\n\n\n\n\nThe default implementation, and the one you'll most likely interact with, is\n\nZend\\Expressive\\Session\\Session\n.\n\n\nUsage\n\n\nSession containers will typically be passed to your middleware using the\n\nSessionMiddleware\n, via the\n\nZend\\Expressive\\Session\\SessionMiddleware::SESSION_ATTRIBUTE\n (\"session\")\nrequest attribute.\n\n\nOnce you have the container, you can check for data:\n\n\nif ($session->has('user')) {\n}\n\n\n\n\nand retrieve it:\n\n\n$user = $session->get('user');\n\n\n\n\nYou can combine those operations, by passing a default value as a second\nargument to the \nget()\n method:\n\n\n$user = $session->get('user', new GuestUser());\n\n\n\n\nIf a datum is no longer relevant in the session, \nunset()\n it:\n\n\n$session->unset('user');\n\n\n\n\nIf none of the data is relevant, \nclear()\n the session:\n\n\n$session->clear();\n\n\n\n\nLazy Sessions\n\n\nThis package provides another implementation of \nSessionInterface\n via\n\nZend\\Expressive\\Session\\LazySession\n. This implementation does the following:\n\n\n\n\nIt composes a \npersistence\n instance, along with the current\n  request.\n\n\nOn \nfirst access\n (e.g., \nget()\n, \nset()\n, etc.), it uses the composed\n  persistence and request instances to generate the \nactual\n session container.\n  All methods then \nproxy\n to this container.\n\n\n\n\nThis approach helps delay any I/O or network operations, and/or\ndeserialization, until they are actually needed.\n\n\nThe shipped \nSessionMiddleware\n produces a \nLazySession\n.\n\n\nSession Regeneration\n\n\nSome application events benefit from \nsession regeneration\n. In particular,\nafter a user has successfully logged in or out, you will generally want to\nregenerate the session in order to prevent session fixation and the attack\nvectors it invites.\n\n\nIn those situations, call \nregenerate()\n:\n\n\n$newSession = $session->regenerate();\n\n\n\n\nThe interface indicates that a new instance \nshould\n be returned. However, in\nthe default usage, you will have a \nLazySession\n instance (as described above),\nwhich \ndecorates\n the underlying session storage. This is done for two reasons:\n\n\n\n\nFirst, the stated reasons of preventing the need to deserialize data and/or\n  perform I/O access until the last moment.\n\n\nSecond, to ensure that the \nSessionMiddleware\n \nalways has a pointer to the\n  session\n.\n\n\n\n\nThis latter is what allows you to regenerate the session in middleware nested\ndeep in your application, but still have the data persisted correctly.",
            "title": "Session Containers"
        },
        {
            "location": "/session/#session-containers",
            "text": "Session containers are the primary interface with which most application\ndevelopers will work; they contain the data currently in the session, and allow\nyou to push data to the session.  All session containers implement  Zend\\Expressive\\Session\\SessionInterface :  namespace Zend\\Expressive\\Session;\n\ninterface SessionInterface\n{\n    /**\n     * Serialize the session data to an array for storage purposes.\n     */\n    public function toArray() : array;\n\n    /**\n     * Retrieve a value from the session.\n     *\n     * @param mixed $default Default value to return if $name does not exist.\n     * @return mixed\n     */\n    public function get(string $name, $default = null);\n\n    /**\n     * Whether or not the container has the given key.\n     */\n    public function has(string $name) : bool;\n\n    /**\n     * Set a value within the session.\n     *\n     * Values MUST be serializable in any format; we recommend ensuring the\n     * values are JSON serializable for greatest portability.\n     *\n     * @param mixed $value\n     */\n    public function set(string $name, $value) : void;\n\n    /**\n     * Remove a value from the session.\n     */\n    public function unset(string $name) : void;\n\n    /**\n     * Clear all values.\n     */\n    public function clear() : void;\n\n    /**\n     * Does the session contain changes? If not, the middleware handling\n     * session persistence may not need to do more work.\n     */\n    public function hasChanged() : bool;\n\n    /**\n     * Regenerate the session.\n     *\n     * This can be done to prevent session fixation. When executed, it SHOULD\n     * return a new instance; that instance should always return true for\n     * isRegenerated().\n     *\n     * An example of where this WOULD NOT return a new instance is within the\n     * shipped LazySession, where instead it would return itself, after\n     * internally re-setting the proxied session.\n     */\n    public function regenerate(): SessionInterface;\n\n    /**\n     * Method to determine if the session was regenerated; should return\n     * true if the instance was produced via regenerate().\n     */\n    public function isRegenerated() : bool;\n}  The default implementation, and the one you'll most likely interact with, is Zend\\Expressive\\Session\\Session .",
            "title": "Session Containers"
        },
        {
            "location": "/session/#usage",
            "text": "Session containers will typically be passed to your middleware using the SessionMiddleware , via the Zend\\Expressive\\Session\\SessionMiddleware::SESSION_ATTRIBUTE  (\"session\")\nrequest attribute.  Once you have the container, you can check for data:  if ($session->has('user')) {\n}  and retrieve it:  $user = $session->get('user');  You can combine those operations, by passing a default value as a second\nargument to the  get()  method:  $user = $session->get('user', new GuestUser());  If a datum is no longer relevant in the session,  unset()  it:  $session->unset('user');  If none of the data is relevant,  clear()  the session:  $session->clear();",
            "title": "Usage"
        },
        {
            "location": "/session/#lazy-sessions",
            "text": "This package provides another implementation of  SessionInterface  via Zend\\Expressive\\Session\\LazySession . This implementation does the following:   It composes a  persistence  instance, along with the current\n  request.  On  first access  (e.g.,  get() ,  set() , etc.), it uses the composed\n  persistence and request instances to generate the  actual  session container.\n  All methods then  proxy  to this container.   This approach helps delay any I/O or network operations, and/or\ndeserialization, until they are actually needed.  The shipped  SessionMiddleware  produces a  LazySession .",
            "title": "Lazy Sessions"
        },
        {
            "location": "/session/#session-regeneration",
            "text": "Some application events benefit from  session regeneration . In particular,\nafter a user has successfully logged in or out, you will generally want to\nregenerate the session in order to prevent session fixation and the attack\nvectors it invites.  In those situations, call  regenerate() :  $newSession = $session->regenerate();  The interface indicates that a new instance  should  be returned. However, in\nthe default usage, you will have a  LazySession  instance (as described above),\nwhich  decorates  the underlying session storage. This is done for two reasons:   First, the stated reasons of preventing the need to deserialize data and/or\n  perform I/O access until the last moment.  Second, to ensure that the  SessionMiddleware   always has a pointer to the\n  session .   This latter is what allows you to regenerate the session in middleware nested\ndeep in your application, but still have the data persisted correctly.",
            "title": "Session Regeneration"
        },
        {
            "location": "/persistence/",
            "text": "Session Persistence\n\n\nSession persistence within zend-expressive-session refers to one or both of the\nfollowing:\n\n\n\n\nIdentifying session information provided by the client making the request.\n\n\nStoring session data for access on subsequent requests.\n\n\nProviding session information to the client making the request.\n\n\n\n\nIn some scenarios, such as usage of JSON Web Tokens (JWT), the serialized\nsession data is provided \nby\n the client, and provided \nto\n the client directly,\nwithout any server-side storage whatsoever.\n\n\nTo describe these operations, we provide \nZend\\Expressive\\Session\\SessionPersistenceInterface\n:\n\n\nnamespace Zend\\Expressive\\Session;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface SessionPersistenceInterface\n{\n    /**\n     * Generate a session data instance based on the request.\n     */\n    public function initializeSessionFromRequest(ServerRequestInterface $request) : SessionInterface;\n\n    /**\n     * Persist the session data instance.\n     *\n     * Persists the session data, returning a response instance with any\n     * artifacts required to return to the client.\n     */\n    public function persistSession(SessionInterface $session, ResponseInterface $response) : ResponseInterface;\n}\n\n\n\n\nSession initialization pulls data from the request (a cookie, a header value,\netc.) in order to produce a session container. Session persistence pulls data\nfrom the session container, does something with it, and then optionally provides\na response containing session artifacts (a cookie, a header value, etc.).\n\n\nFor sessions to work, \nyou must provide a persistence implementation\n. We\nprovide one such implementation using PHP's session extension via the package\n\nzend-expressive-session-ext\n.",
            "title": "Session Persistence"
        },
        {
            "location": "/persistence/#session-persistence",
            "text": "Session persistence within zend-expressive-session refers to one or both of the\nfollowing:   Identifying session information provided by the client making the request.  Storing session data for access on subsequent requests.  Providing session information to the client making the request.   In some scenarios, such as usage of JSON Web Tokens (JWT), the serialized\nsession data is provided  by  the client, and provided  to  the client directly,\nwithout any server-side storage whatsoever.  To describe these operations, we provide  Zend\\Expressive\\Session\\SessionPersistenceInterface :  namespace Zend\\Expressive\\Session;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface SessionPersistenceInterface\n{\n    /**\n     * Generate a session data instance based on the request.\n     */\n    public function initializeSessionFromRequest(ServerRequestInterface $request) : SessionInterface;\n\n    /**\n     * Persist the session data instance.\n     *\n     * Persists the session data, returning a response instance with any\n     * artifacts required to return to the client.\n     */\n    public function persistSession(SessionInterface $session, ResponseInterface $response) : ResponseInterface;\n}  Session initialization pulls data from the request (a cookie, a header value,\netc.) in order to produce a session container. Session persistence pulls data\nfrom the session container, does something with it, and then optionally provides\na response containing session artifacts (a cookie, a header value, etc.).  For sessions to work,  you must provide a persistence implementation . We\nprovide one such implementation using PHP's session extension via the package zend-expressive-session-ext .",
            "title": "Session Persistence"
        },
        {
            "location": "/middleware/",
            "text": "Session Middleware\n\n\nzend-expressive-session provides middleware consuming\n\nPSR-7\n HTTP message instances, via\nimplementation of \nhttp-interop/http-middleware\n\ninterfaces.\n\n\nThis middleware composes a \npersistence\n instance, and uses that\nin order to generate a session container, which it pushes into the request it\ndelegates to the next middleware. Once a response is returned, it uses the\npersistence instance to persist the session data and provide information back to\nthe client.\n\n\nThe above two paragraphs are longer than the body of the middleware\nimplementation:\n\n\nnamespace Zend\\Expressive\\Session;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass SessionMiddleware implements MiddlewareInterface\n{\n    const SESSION_ATTRIBUTE = 'session';\n\n    private $persistence;\n\n    public function __construct(SessionPersistenceInterface $persistence)\n    {\n        $this->persistence = $persistence;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate) : ResponseInterface\n    {\n        $session = new LazySession($this->persistence, $request);\n        $response = $delegate->process($request->withAttribute(self::SESSION_ATTRIBUTE, $session));\n        return $this->persistence->persistSession($session, $response);\n    }\n}\n\n\n\n\nConfiguration\n\n\nThis package provides a factory for \nZend\\Expressive\\Session\\SessionMiddleware\n\nvia \nZend\\Expressive\\Session\\SessionMiddlewareFactory\n; this factory is\nauto-wired if you are using Expressive and the zend-component-installer Composer\nplugin. If not, you will need to wire these into your application.\n\n\nThe factory depends on one service: \nZend\\Expressive\\Session\\SessionPersistenceInterface\n.\nYou will need to either wire in your persistence implementation of choice, or\nhave the package providing it do so for you.\n\n\nAdding the middleware to your application\n\n\nYou may pipe this middleware anywhere in your application. If you want to have\nit available anywhere, pipe it early in your application, prior to any routing.\nAs an example, within Expressive, you could pipe it in the \nconfig/pipeline.php\n\nfile:\n\n\n$app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class);\n$app->pipeRoutingMiddleware();\n\n\n\n\nThis will generally be an inexpensive operation; since the middleware uses a\n\nLazySession\n instance, unless your persistence implementation does any work in\nits constructor, the cost is just that of instantiating a few objects.\n\n\nHowever, it's often useful to specifically include such middleware directly in\nthe routed middleware pipelines, to ensure other developers are aware of its\npresence in that route's workflow.\n\n\nWithin Expressive, you can do this when routing, in your \nconfig/routes.php\n\nfile, or within a \ndelegator factory\n:\n\n\n$app->post('/login', [\n    \\Zend\\Expressive\\Session\\SessionMiddleware::class,\n    \\User\\Middleware\\LoginHandler::class\n]);",
            "title": "Session Middleware"
        },
        {
            "location": "/middleware/#session-middleware",
            "text": "zend-expressive-session provides middleware consuming PSR-7  HTTP message instances, via\nimplementation of  http-interop/http-middleware \ninterfaces.  This middleware composes a  persistence  instance, and uses that\nin order to generate a session container, which it pushes into the request it\ndelegates to the next middleware. Once a response is returned, it uses the\npersistence instance to persist the session data and provide information back to\nthe client.  The above two paragraphs are longer than the body of the middleware\nimplementation:  namespace Zend\\Expressive\\Session;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass SessionMiddleware implements MiddlewareInterface\n{\n    const SESSION_ATTRIBUTE = 'session';\n\n    private $persistence;\n\n    public function __construct(SessionPersistenceInterface $persistence)\n    {\n        $this->persistence = $persistence;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate) : ResponseInterface\n    {\n        $session = new LazySession($this->persistence, $request);\n        $response = $delegate->process($request->withAttribute(self::SESSION_ATTRIBUTE, $session));\n        return $this->persistence->persistSession($session, $response);\n    }\n}",
            "title": "Session Middleware"
        },
        {
            "location": "/middleware/#configuration",
            "text": "This package provides a factory for  Zend\\Expressive\\Session\\SessionMiddleware \nvia  Zend\\Expressive\\Session\\SessionMiddlewareFactory ; this factory is\nauto-wired if you are using Expressive and the zend-component-installer Composer\nplugin. If not, you will need to wire these into your application.  The factory depends on one service:  Zend\\Expressive\\Session\\SessionPersistenceInterface .\nYou will need to either wire in your persistence implementation of choice, or\nhave the package providing it do so for you.",
            "title": "Configuration"
        },
        {
            "location": "/middleware/#adding-the-middleware-to-your-application",
            "text": "You may pipe this middleware anywhere in your application. If you want to have\nit available anywhere, pipe it early in your application, prior to any routing.\nAs an example, within Expressive, you could pipe it in the  config/pipeline.php \nfile:  $app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class);\n$app->pipeRoutingMiddleware();  This will generally be an inexpensive operation; since the middleware uses a LazySession  instance, unless your persistence implementation does any work in\nits constructor, the cost is just that of instantiating a few objects.  However, it's often useful to specifically include such middleware directly in\nthe routed middleware pipelines, to ensure other developers are aware of its\npresence in that route's workflow.  Within Expressive, you can do this when routing, in your  config/routes.php \nfile, or within a  delegator factory :  $app->post('/login', [\n    \\Zend\\Expressive\\Session\\SessionMiddleware::class,\n    \\User\\Middleware\\LoginHandler::class\n]);",
            "title": "Adding the middleware to your application"
        }
    ]
}